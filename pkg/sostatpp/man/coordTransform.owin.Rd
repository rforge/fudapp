% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/transformxy-generic.R
\name{coordTransform.owin}
\alias{coordTransform.owin}
\title{Apply Coordinate Transformation to Window}
\usage{
\method{coordTransform}{owin}(X, trafoxy = identxy, invtrafoxy = NULL,
  subdivideBorder = TRUE, ...)
}
\arguments{
\item{X}{Window (object of class \code{"owin"}).}

\item{trafoxy}{The coordinate transformation function, defaults to the identical
map \code{\link{identxy}}, see also `Details'.}

\item{invtrafoxy}{The inverse to \code{trafoxy}, defaults to the identical map
\code{\link{identxy}}. Only needed if \code{X} is a pixel image.}

\item{subdivideBorder}{If TRUE, subdivision of rectangle or polygon borders to achieve better precision,
see the `Details'.}

\item{...}{Optional arguments passed to \code{trafoxy} and \code{invtrafoxy},
and / or to  \code{\link{as.mask}} controlling the
pixel resolution of the transformed window, if \code{X} is a binary pixel
mask, and / or to \code{\link{refinepoly}}, if \code{X} is a polygon or a
rectangle, see the `Details'.}
}
\description{
Apply any coordinate transformation to a window.
Compare the spatstat function \code{\link{affine.owin}}.
}
\details{
The functions \code{trafoxy} (and \code{invtrafoxy}) take one
    or two arguments. In the latter case, both arguments are vectors of
    same length (not checked!), and the second argument has to be named \code{y}.
    If only one argument is given, it is a list or a data frame with elements
    \code{x} and \code{y}.

     If the window is a rectangle or polygon, it is converted into a
     polygon which is subsequently refined using \code{\link{refinepoly}},
     unless \code{subdivideBorder = FALSE}. This is only necessary if the coordinate
     transform is not affine, in order to achieve a better approximation of
     the transformed window. Note however that \code{coordTransform.owin} does
     not check whether \code{trafoxy} really is affine. The option
     \code{subdivideBorder = FALSE} may therefore also be used to save memory and
     computation time when transforming xy-rectangles with a transformation
     that preserves axe-parallel rectangles.
}
\examples{
# transformation of the polygonal window letterR from spatstat

# a nonlinear transformation
trafo <- function(xy, a = 1.5) list(x = xy$x^a + 0.5*xy$y, y = xy$y*.5)

# transform letterR and mark the boundary corners,
# dummy variable for silent return
plot(letterR)
dummy <- lapply(letterR$bdry, points, col = "red")
mappedR <- coordTransform(letterR, trafo, edgelen = 0.1, a=1.2)
plot(mappedR)
dummy <- lapply(mappedR$bdry, points, col = "red")

# no refinement, assuming that trafo is affine
mappedRcoarse <- coordTransform(letterR, trafo, subdivideBorder = FALSE)
plot(mappedRcoarse, add = TRUE)
dummy <- lapply(mappedRcoarse$bdry, points, col = "green")
# not much of a difference, though...

# now as mask image. We need the inverse transformation, too

invtrafo <- function(xy, a = 1.5) list(x = (xy$x - xy$y) ^(1/a), y = xy$y*2)
wimR <- as.owin(as.im(letterR))
# eps controlles the pixel size of the transformed image, via as.mask
mappedimR <- coordTransform(wimR, trafo, invtrafo, a = 1.2, eps = 0.02)
plot(mappedimR)
# compare with the polygonal window from before
plot(mappedR, col = "green", add = TRUE)
}
\author{
Ute Hahn,  \email{ute@imf.au.dk}
}
\seealso{
\code{\link{coordTransform.im}}, which is called if \code{X} is a pixel image.
}
\keyword{manip}
\keyword{spatial}

